package org.apache.flink.examples.java.ml.util;

import java.util.Arrays;

/**
 * Contains the input variables for the L-BFGS algorithm and also its return values.
 */
public class State{

	private int n;
	private int m;
	private double[] x;
	private double f;
	private double[] g;
	private boolean diagco;
	private double[] diag;
	private int[] iprint;
	private double eps;
	private double xtol;
	private int[] iflag;

	/** Controls the accuracy of the line search <code>mcsrch</code>. If the
	 * function and gradient evaluations are inexpensive with respect
	 * to the cost of the iteration (which is sometimes the case when
	 * solving very large problems) it may be advantageous to set <code>gtol</code>
	 * to a small value. A typical small value is 0.1.  Restriction:
	 * <code>gtol</code> should be greater than 1e-4.
	 */

	public double gtol = 0.9;

	/** Specify lower bound for the step in the line search.
	 * The default value is 1e-20. This value need not be modified unless
	 * the exponent is too large for the machine being used, or unless
	 * the problem is extremely badly scaled (in which case the exponent
	 * should be increased).
	 */

	public double stpmin = 1e-20;

	/** Specify upper bound for the step in the line search.
	 * The default value is 1e20. This value need not be modified unless
	 * the exponent is too large for the machine being used, or unless
	 * the problem is extremely badly scaled (in which case the exponent
	 * should be increased).
	 */

	public double stpmax = 1e20;

	/** The solution vector as it was at the end of the most recently
	 * completed line search. This will usually be different from the
	 * return value of the parameter <tt>x</tt> of <tt>lbfgs</tt>, which
	 * is modified by line-search steps. A caller which wants to stop the
	 * optimization iterations before <tt>LBFGS.lbfgs</tt> automatically stops
	 * (by reaching a very small gradient) should copy this vector instead
	 * of using <tt>x</tt>. When <tt>LBFGS.lbfgs</tt> automatically stops,
	 * then <tt>x</tt> and <tt>solution_cache</tt> are the same.
	 */
	public double[] solution_cache = null;

	private double gnorm = 0, stp1 = 0, ftol = 0, stp[] = new double[1], ys = 0, yy = 0, sq = 0, yr = 0, beta = 0, xnorm = 0;
	private int iter = 0, nfun = 0, point = 0, ispt = 0, iypt = 0, maxfev = 0, info[] = new int[1], bound = 0, npt = 0, cp = 0, i = 0, nfev[] = new int[1], inmc = 0, iycn = 0, iscn = 0;
	private boolean finish = false;

	private double[] w = null;

	private Statics statics = new Statics();


	/**
	@param n The number of variables in the minimization problem.
	*		Restriction: <code>n &gt; 0</code>.
		*
		* @param m The number of corrections used in the BFGS update.
		*		Values of <code>m</code> less than 3 are not recommended;
	*		large values of <code>m</code> will result in excessive
	*		computing time. <code>3 &lt;= m &lt;= 7</code> is recommended.
		*		Restriction: <code>m &gt; 0</code>.
		*
		* @param x On initial entry this must be set by the user to the values
	*		of the initial estimate of the solution vector. On exit with
	*		<code>iflag = 0</code>, it contains the values of the variables
	*		at the best point found (usually a solution).
		*
		* @param f Before initial entry and on a re-entry with <code>iflag = 1</code>,
		*		it must be set by the user to contain the value of the function
	*		<code>f</code> at the point <code>x</code>.
		*
		* @param g Before initial entry and on a re-entry with <code>iflag = 1</code>,
		*		it must be set by the user to contain the components of the
	*		gradient <code>g</code> at the point <code>x</code>.
		*
		* @param diagco  Set this to <code>true</code> if the user  wishes to
	*		provide the diagonal matrix <code>Hk0</code> at each iteration.
	*		Otherwise it should be set to <code>false</code> in which case
		*		<code>lbfgs</code> will use a default value described below. If
	*		<code>diagco</code> is set to <code>true</code> the routine will
	*		return at each iteration of the algorithm with <code>iflag = 2</code>,
		*		and the diagonal matrix <code>Hk0</code> must be provided in
	*		the array <code>diag</code>.
		*
		* @param diag If <code>diagco = true</code>, then on initial entry or on
	*		re-entry with <code>iflag = 2</code>, <code>diag</code>
		*		must be set by the user to contain the values of the
	*		diagonal matrix <code>Hk0</code>. Restriction: all elements of
	*		<code>diag</code> must be positive.
	*
		* @param iprint Specifies output generated by <code>lbfgs</code>.
		*		<code>iprint[0]</code> specifies the frequency of the output:
		*		<ul>
	*		<li> <code>iprint[0] &lt; 0</code>: no output is generated,
	*		<li> <code>iprint[0] = 0</code>: output only at first and last iteration,
		*		<li> <code>iprint[0] &gt; 0</code>: output every <code>iprint[0]</code> iterations.
	*		</ul>
		*
		*		<code>iprint[1]</code> specifies the type of output generated:
		*		<ul>
	*		<li> <code>iprint[1] = 0</code>: iteration count, number of function
	*			evaluations, function value, norm of the gradient, and steplength,
	*		<li> <code>iprint[1] = 1</code>: same as <code>iprint[1]=0</code>, plus vector of
	*			variables and  gradient vector at the initial point,
	*		<li> <code>iprint[1] = 2</code>: same as <code>iprint[1]=1</code>, plus vector of
	*			variables,
		*		<li> <code>iprint[1] = 3</code>: same as <code>iprint[1]=2</code>, plus gradient vector.
	*		</ul>
		*
		*	@param eps Determines the accuracy with which the solution
	*		is to be found. The subroutine terminates when
	*		<pre>
	*            ||G|| &lt; EPS max(1,||X||),
	*		</pre>
		*		where <code>||.||</code> denotes the Euclidean norm.
		*
		*	@param xtol An estimate of the machine precision (e.g. 10e-16 on a
		*		SUN station 3/60). The line search routine will terminate if the
	*		relative width of the interval of uncertainty is less than
	*		<code>xtol</code>.
		*
		* @param iflag This must be set to 0 on initial entry to <code>lbfgs</code>.
		*		A return with <code>iflag &lt; 0</code> indicates an error,
		*		and <code>iflag = 0</code> indicates that the routine has
	*		terminated without detecting errors. On a return with
	*		<code>iflag = 1</code>, the user must evaluate the function
	*		<code>f</code> and gradient <code>g</code>. On a return with
	*		<code>iflag = 2</code>, the user must provide the diagonal matrix
	*		<code>Hk0</code>.
		*
		*		The following negative values of <code>iflag</code>, detecting an error,
		*		are possible:
		*		<ul>
	*		<li> <code>iflag = -1</code> The line search routine
	*			<code>mcsrch</code> failed. One of the following messages
	*			is printed:
		*			<ul>
	*			<li> Improper input parameters.
	*			<li> Relative width of the interval of uncertainty is at
	*				most <code>xtol</code>.
		*			<li> More than 20 function evaluations were required at the
	*				present iteration.
		*			<li> The step is too small.
	*			<li> The step is too large.
	*			<li> Rounding errors prevent further progress. There may not
	*				be  a step which satisfies the sufficient decrease and
	*				curvature conditions. Tolerances may be too small.
	*			</ul>
		*		<li><code>iflag = -2</code> The i-th diagonal element of the diagonal inverse
	*			Hessian approximation, given in DIAG, is not positive.
		*		<li><code>iflag = -3</code> Improper input parameters for LBFGS
	*			(<code>n</code> or <code>m</code> are not positive).
		*		</ul>
		*
	*/

	public State(int n, int m, double[] x, double f, double[] g, boolean diagco, double[] diag, int[] iprint, double eps,
				 double xtol, int[] iflag, double gtol, double stpmin, double stpmax, double[] solution_cache, double gnorm,
				 double stp1, double ftol, double[] stp, double ys, double yy, double sq, double yr, double beta,
				 double xnorm, int iter, int nfun, int point, int ispt, int iypt, int maxfev, int[] info, int bound,
				 int npt, int cp, int i, int[] nfev, int inmc, int iycn, int iscn, boolean finish, double[] w, Statics statics) {
		this.n = n;
		this.m = m;
		this.x = x;
		this.f = f;
		this.g = g;
		this.diagco = diagco;
		this.diag = diag;
		this.iprint = iprint;
		this.eps = eps;
		this.xtol = xtol;
		this.iflag = iflag;
		this.gtol = gtol;
		this.stpmin = stpmin;
		this.stpmax = stpmax;
		this.solution_cache = solution_cache;
		this.gnorm = gnorm;
		this.stp1 = stp1;
		this.ftol = ftol;
		this.stp = stp;
		this.ys = ys;
		this.yy = yy;
		this.sq = sq;
		this.yr = yr;
		this.beta = beta;
		this.xnorm = xnorm;
		this.iter = iter;
		this.nfun = nfun;
		this.point = point;
		this.ispt = ispt;
		this.iypt = iypt;
		this.maxfev = maxfev;
		this.info = info;
		this.bound = bound;
		this.npt = npt;
		this.cp = cp;
		this.i = i;
		this.nfev = nfev;
		this.inmc = inmc;
		this.iycn = iycn;
		this.iscn = iscn;
		this.finish = finish;
		this.w = w;
		this.statics = statics;

	}

	public State(int n, int m, double[] x, double f, double[] g, boolean diagco, double[] diag, int[] iprint, double eps, double xtol, int[] iflag) {
		this.n = n;
		this.m = m;
		this.x = x;
		this.f = f;
		this.g = g;
		this.diagco = diagco;
		this.diag = diag;
		this.iprint = iprint;
		this.eps = eps;
		this.xtol = xtol;
		this.iflag = iflag;
	}

	public State(State state, Double f, double[] g) {
		
		this.f = f;
		this.g = g;
		
		this.n = state.getN();
		this.m = state.getM();
		this.x = state.getX();
		this.diagco = state.isDiagco();
		this.diag = state.getDiag();
		this.iprint = state.getIprint();
		this.eps = state.getEps();
		this.xtol = state.getXtol();
		this.iflag = state.getIflag();
		this.gtol = state.getGtol();
		this.stpmin = state.getStpmin();
		this.stpmax = state.getStpmax();
		this.solution_cache = state.getSolution_cache();
		this.gnorm = state.getGnorm();
		this.stp1 = state.getStp1();
		this.ftol = state.getFtol();
		this.stp = state.getStp();
		this.ys = state.getYs();
		this.yy = state.getYy();
		this.sq = state.getSq();
		this.yr = state.getYr();
		this.beta = state.getBeta();
		this.xnorm = state.getXnorm();
		this.iter = state.getIter();
		this.nfun = state.getNfun();
		this.point = state.getPoint();
		this.ispt = state.getIspt();
		this.iypt = state.getIypt();
		this.maxfev = state.getMaxfev();
		this.info = state.getInfo();
		this.bound = state.getBound();
		this.npt = state.getNpt();
		this.cp = state.getCp();
		this.i = state.getI();
		this.nfev = state.getNfev();
		this.inmc = state.getInmc();
		this.iycn = state.getIycn();
		this.iscn = state.getIscn();
		this.finish = state.isFinish();
		this.w = state.getW();
		this.statics = state.getStatics();
	}

	public int getN() {
		return n;
	}

	public void setN(int n) {
		this.n = n;
	}

	public int getM() {
		return m;
	}

	public void setM(int m) {
		this.m = m;
	}

	public double[] getX() {
		return x;
	}

	public void setX(double[] x) {
		this.x = x;
	}

	public double getF() {
		return f;
	}

	public void setF(double f) {
		this.f = f;
	}

	public double[] getG() {
		return g;
	}

	public void setG(double[] g) {
		this.g = g;
	}

	public boolean isDiagco() {
		return diagco;
	}

	public void setDiagco(boolean diagco) {
		this.diagco = diagco;
	}

	public double[] getDiag() {
		return diag;
	}

	public void setDiag(double[] diag) {
		this.diag = diag;
	}

	public int[] getIprint() {
		return iprint;
	}

	public void setIprint(int[] iprint) {
		this.iprint = iprint;
	}

	public double getEps() {
		return eps;
	}

	public void setEps(double eps) {
		this.eps = eps;
	}

	public double getXtol() {
		return xtol;
	}

	public void setXtol(double xtol) {
		this.xtol = xtol;
	}

	public int[] getIflag() {
		return iflag;
	}

	public void setIflag(int[] iflag) {
		this.iflag = iflag;
	}

	public double getGtol() {
		return gtol;
	}

	public void setGtol(double gtol) {
		this.gtol = gtol;
	}

	public double getStpmin() {
		return stpmin;
	}

	public void setStpmin(double stpmin) {
		this.stpmin = stpmin;
	}

	public double getStpmax() {
		return stpmax;
	}

	public void setStpmax(double stpmax) {
		this.stpmax = stpmax;
	}

	public double[] getSolution_cache() {
		return solution_cache;
	}

	public void setSolution_cache(double[] solution_cache) {
		this.solution_cache = solution_cache;
	}

	public double getGnorm() {
		return gnorm;
	}

	public void setGnorm(double gnorm) {
		this.gnorm = gnorm;
	}

	public double getStp1() {
		return stp1;
	}

	public void setStp1(double stp1) {
		this.stp1 = stp1;
	}

	public double getFtol() {
		return ftol;
	}

	public void setFtol(double ftol) {
		this.ftol = ftol;
	}

	public double[] getStp() {
		return stp;
	}

	public void setStp(double[] stp) {
		this.stp = stp;
	}

	public double getYs() {
		return ys;
	}

	public void setYs(double ys) {
		this.ys = ys;
	}

	public double getYy() {
		return yy;
	}

	public void setYy(double yy) {
		this.yy = yy;
	}

	public double getSq() {
		return sq;
	}

	public void setSq(double sq) {
		this.sq = sq;
	}

	public double getYr() {
		return yr;
	}

	public void setYr(double yr) {
		this.yr = yr;
	}

	public double getBeta() {
		return beta;
	}

	public void setBeta(double beta) {
		this.beta = beta;
	}

	public double getXnorm() {
		return xnorm;
	}

	public void setXnorm(double xnorm) {
		this.xnorm = xnorm;
	}

	public int getIter() {
		return iter;
	}

	public void setIter(int iter) {
		this.iter = iter;
	}

	public int getNfun() {
		return nfun;
	}

	public void setNfun(int nfun) {
		this.nfun = nfun;
	}

	public int getPoint() {
		return point;
	}

	public void setPoint(int point) {
		this.point = point;
	}

	public int getIspt() {
		return ispt;
	}

	public void setIspt(int ispt) {
		this.ispt = ispt;
	}

	public int getIypt() {
		return iypt;
	}

	public void setIypt(int iypt) {
		this.iypt = iypt;
	}

	public int getMaxfev() {
		return maxfev;
	}

	public void setMaxfev(int maxfev) {
		this.maxfev = maxfev;
	}

	public int[] getInfo() {
		return info;
	}

	public void setInfo(int[] info) {
		this.info = info;
	}

	public int getBound() {
		return bound;
	}

	public void setBound(int bound) {
		this.bound = bound;
	}

	public int getNpt() {
		return npt;
	}

	public void setNpt(int npt) {
		this.npt = npt;
	}

	public int getCp() {
		return cp;
	}

	public void setCp(int cp) {
		this.cp = cp;
	}

	public int getI() {
		return i;
	}

	public void setI(int i) {
		this.i = i;
	}

	public int[] getNfev() {
		return nfev;
	}

	public void setNfev(int[] nfev) {
		this.nfev = nfev;
	}

	public int getInmc() {
		return inmc;
	}

	public void setInmc(int inmc) {
		this.inmc = inmc;
	}

	public int getIycn() {
		return iycn;
	}

	public void setIycn(int iycn) {
		this.iycn = iycn;
	}

	public int getIscn() {
		return iscn;
	}

	public void setIscn(int iscn) {
		this.iscn = iscn;
	}

	public boolean isFinish() {
		return finish;
	}

	public void setFinish(boolean finish) {
		this.finish = finish;
	}

	public double[] getW() {
		return w;
	}

	public void setW(double[] w) {
		this.w=w;
	}

	public Statics getStatics() {
		return statics;
	}

	public void setStatics(Statics statics) {
		this.statics = statics;
	}

	@Override
	public String toString() {
		return "Weights{" +
			"x=" + Arrays.toString(x) +
			'}';
	}
}
